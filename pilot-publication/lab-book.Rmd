# Lab book for the TERN pilot publication

This file includes code and scripts used to experiment and explore with the TERN pilot data. 

```{r setup}
library(pbapply)
library(openssl)
library(dotenv)
```


## Generate synthetic data

Because developing on the server is generally slow, a first step to speed up development was to generate a synthetic dataset that could be safely used locally. Check [main.R](./main.R) to make sure that `data` is in the correct state before creating the synthetic data using the code below.

```{r, synthetic-data-generation}
## Generate synthetic data. For each column, sample from the same distribution as the original data, but do not keep correlations present in the orginal data.
synth.data <- lapply(data, function(column) {
    if (is.factor(column)) {
        return (as.factor(sample(levels(column), size = length(column), replace = TRUE)))
    } else if (is.character(column)) {
        return (as.character(sample(column, size = length(column), replace = TRUE)))
    } else if (is.numeric(column)) {
        return (rnorm(n = length(column), mean = mean(column, na.rm = TRUE), sd = sd(column, na.rm = TRUE)))
    } else if (is.logical(column)) {
        return (sample(c(TRUE, FALSE), size = length(column), replace = TRUE))
    } else if (is.POSIXct(column) | is.POSIXt(column)) {
        return (as.POSIXct(sample(as.numeric(column), size = length(column), replace = TRUE), origin = "1970-01-01"))
    } else {
        return (rep(NA, length(column)))
    }
}) %>% as.data.frame()

## Replace values in columns with character values with random strings
synth.data[, sapply(synth.data, is.character)] <- lapply(synth.data[, sapply(synth.data, is.character)], function(column) {
    n.unique <- length(unique(column))
    new.values <- replicate(n.unique, paste(sample(letters, size = 10, replace = TRUE), collapse = ""))
    new.values <- rep(new.values, length.out = length(column))
    return (new.values)
})

## Replace values in any variable with id in the name random numbers
id.vars <- c("X_id", "id__reg_hospital_id", "id__assigned_patient_id", "meta__instanceID", "meta__deprecatedID", "formhub__uuid", "X_xform_id_string", "X_uuid")
synth.data[, id.vars] <- lapply(synth.data[, id.vars], function(column) {
    n.unique <- length(unique(column))
    new.values <- rep(sample(1:1e6, size = n.unique, replace = FALSE), length.out = length(column))
    return (new.values)
})

## Check that no rows in the original data are present in the synthetic data
stopifnot(!any(pbapply(data, 1, function(row) {
    any(apply(synth.data, 1, function(synth.row) {
        all(row == synth.row, na.rm = TRUE)
    }))
})))

## Encrypt synthetic data before writing to file
key <- sha256(charToRaw(Sys.getenv("SYNTH_DATA_KEY")))
encrypted.synth.data <- aes_cbc_encrypt(serialize(synth.data, NULL), key = key)

## Write synthetic data to file
saveRDS(encrypted.synth.data, file = "data/synth-data.rds")

## Encrypt and write codebook to file, but first remove the settings entry
codebook$settings <- NULL
encrypted.codebook <- aes_cbc_encrypt(serialize(codebook, NULL), key = key)
saveRDS(encrypted.codebook, file = "data/codebook.rds")
```

To develop locally both the data and the codebook need to be loaded.

```{r load-data}
key <- sha256(charToRaw(Sys.getenv("SYNTH_DATA_KEY")))
data <- unserialize(aes_cbc_decrypt(readRDS("data/synth-data.rds"), key = key))
codebook <- unserialize(aes_cbc_decrypt(readRDS("data/codebook.rds"), key = key))
```
