# Lab book for the TERN pilot publication

This file includes code and scripts used to experiment and explore with the TERN pilot data. 

```{r setup}
library(pbapply)
library(openssl)
library(dotenv)
```


## Generate synthetic data

Because developing on the server is generally slow, a first step to speed up development was to generate a synthetic dataset that could be safely used locally. Check [main.R](./main.R) to make sure that `data` is in the correct state before creating the synthetic data using the code below.

```{r, synthetic-data-generation}
## Generate synthetic data. For each column, sample from the same distribution as the original data, but do not keep correlations present in the orginal data.
synth.data <- lapply(data, function(column) {
    if (is.factor(column)) {
        return (as.factor(sample(levels(column), size = length(column), replace = TRUE)))
    } else if (is.character(column)) {
        return (as.character(sample(column, size = length(column), replace = TRUE)))
    } else if (is.numeric(column)) {
        return (rnorm(n = length(column), mean = mean(column, na.rm = TRUE), sd = sd(column, na.rm = TRUE)))
    } else if (is.logical(column)) {
        return (sample(c(TRUE, FALSE), size = length(column), replace = TRUE))
    } else if (is.POSIXct(column) | is.POSIXt(column)) {
        return (as.POSIXct(sample(as.numeric(column), size = length(column), replace = TRUE), origin = "1970-01-01"))
    } else {
        return (rep(NA, length(column)))
    }
}) %>% as.data.frame()

## Replace values in columns with character values with random strings
synth.data[, sapply(synth.data, is.character)] <- lapply(synth.data[, sapply(synth.data, is.character)], function(column) {
    n.unique <- length(unique(column))
    new.values <- replicate(n.unique, paste(sample(letters, size = 10, replace = TRUE), collapse = ""))
    new.values <- rep(new.values, length.out = length(column))
    return (new.values)
})

## Replace values in any variable with id in the name random numbers
id.vars <- c("X_id", "id__reg_hospital_id", "id__assigned_patient_id", "meta__instanceID", "meta__deprecatedID", "formhub__uuid", "X_xform_id_string", "X_uuid")
synth.data[, id.vars] <- lapply(synth.data[, id.vars], function(column) {
    n.unique <- length(unique(column))
    new.values <- rep(sample(1:1e6, size = n.unique, replace = FALSE), length.out = length(column))
    return (new.values)
})

## Check that no rows in the original data are present in the synthetic data
stopifnot(!any(pbapply(data, 1, function(row) {
    any(apply(synth.data, 1, function(synth.row) {
        all(row == synth.row, na.rm = TRUE)
    }))
})))

## Encrypt synthetic data before writing to file
key <- sha256(charToRaw(Sys.getenv("SYNTH_DATA_KEY")))
encrypted.synth.data <- aes_cbc_encrypt(serialize(synth.data, NULL), key = key)

## Write synthetic data to file
saveRDS(encrypted.synth.data, file = "data/synth-data.rds")

## Encrypt and write codebook to file, but first remove the settings entry
codebook$settings <- NULL
encrypted.codebook <- aes_cbc_encrypt(serialize(codebook, NULL), key = key)
saveRDS(encrypted.codebook, file = "data/codebook.rds")
```

To develop locally both the data and the codebook need to be loaded.

```{r load-data}
key <- sha256(charToRaw(Sys.getenv("SYNTH_DATA_KEY")))
data <- unserialize(aes_cbc_decrypt(readRDS("data/synth-data.rds"), key = key))
codebook <- unserialize(aes_cbc_decrypt(readRDS("data/codebook.rds"), key = key))
```

Probably a good idea to wrap the generation of these results into a function, and introduce a test argument, to prevent us from introducing local results in the main manuscript.

```{r basic-results}
get_basic_results <- function(test = FALSE) {
    results <- list()
    ## Define basic results
    arrival.dates <- data %>% pull(incident__date_of_arrival) %>% as.Date()
    results$start.date <- arrival.dates %>% min() %>% format_date()
    results$end.date <- arrival.dates %>% max() %>% format_date()
    n.no.consent <-  list("11542" = 40,
                          "44805" = 10,
                          "55356" = 43,
                          "78344" = 3,
                          "95846" = 9, 
                          "88456" = 0, # To be updated
                          "10263" = 2)
    results$icc <- estimate_icc("outcomes__discharge_alive", "id__reg_hospital_id", data)
    results$n.patients <- nrow(data)
    results$n.atls.residents <- 4 + 2 # The total number of residents trained in ATLS, per ATLS centre
    results$n.ptc.residents <- 9 + 6 # The total number of residents trained in PTC, per centre
    results$n.residents <- with(results, n.atls.residents + n.ptc.residents)
    results$n.centres <-  data %>% pull(id__reg_hospital_id) %>% unique() %>% length()
    results$n.atls <- sum(data$arm == "ATLS")
    results$n.ptc <- sum(data$arm == "PTC")
    results$n.control <- sum(data$arm == "Standard care")
    results$n.females <- with(data, sum(patinfo__pt_gender == "Female"))
    results$p.females <- round(results$n.females/nrow(data) * 100)
    results$median.age <- median(data$patinfo__pt_age, na.rm = TRUE)
    results$iqr.age <- get_iqr(data$patinfo__pt_age)
    results$median.iss <- median(data$riss, na.rm = TRUE)
    results$iqr.iss <- get_iqr(data$riss)
    results$median.niss <- median(data$niss, na.rm = TRUE)
    results$iqr.niss <- get_iqr(data$niss)
    results$n.admitted <- with(data, sum(interventions__admitted == "Yes"))
    results$p.admitted <- round(results$n.admitted/nrow(data) * 100)
    return (results)
}
```
